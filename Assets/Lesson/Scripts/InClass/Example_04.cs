//#define EXAMPLE_TYPE_VALUE
//#define EXAMPLE_TYPE_REFERENCE
#define EXAMPLE_TYPE_NULLABLE

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#region 즐거운 세계 C#
/*

▶ C# 언어의 문법을 숙지해야 하는 이유

- 유니티에서 기본적으로 스크립트는 C#을 채용한다.
ㄴ 이는 엔진의 활용성 + 최적화를 높이기 위해 C#에 대한 이해도를 요구한다.

- C / C++ 스타일로 C# 문법을 모르고 작성하는것도 가능은 하지만 결국엔 최적화와 효율 문제로 GG


▶ C# 동작 방식 (프로그램)

- C# 프로그램은 CLR(Common Language Runtime) 이라는 자바의 가상 머신과 비슷한 프로그램 위에서 구동이 된다.
ㄴ 이는 C / C++ 언어와 달리 결과물이 컴퓨터가 바로 실행 할 수 있는 실행 파일로 생성되지 않는다는 것을 의미한다.


◈ CLR
ㄴ 마소에서 개발한 가상 머신의 구성요소라고 할 수 있다. (윈도우 전용)
ㄴ 기능은 크게 2가지
    ㄴ 1. 중간 언어를 JIT 컴파일러를 통해 기계어로 변환 가능
    ㄴ 2. 가비지 컬렉션을 통한 메모리 관리 (동적)


▷ CLR의 역할 3가지
ㄴ a. 예외 처리
ㄴ b. 메모리 관리
ㄴ c. 언어간 호환성을 체크 (CTS)
    ㄴ 닷넷 프레임워크는 C# 언어만을 위한 프레임워크가 아니기 때문에 C# 언어를 제외한 다른 언어에서도 닷넷 프레임워크를 이용하는 것이 가능하다.
    ㄴ 이때 발생하는 언어간 문법적인 차이를 CLR을 통해 통일화 시키는것이 가능
    ㄴ 통일이 가능한 이유는 내부적으로 CTS 규칙에 따라 데이터 타입을 구현하고 있기 때문에


◈ 가상 머신
ㄴ 컴퓨터에 가상의 컴퓨팅을 하는 기법
ㄴ 새로운 OS를 만드는 기법

- C#은 CLR이라는 중간 과정을 거쳐서 다른 언어를 사용할 수 있게 지원을 한다.

- CLR은 CIL 코드를 읽어들여 OS가 이해할 수 있는 Native Code로 변환시켜주는 역할을 수행한다.

- 이때 서로 다른 언어들이 만나는 지점 "IL"이라고 하는 곳이며 이 언어로 쓰여진 코드를 CLR이
다시 자신이 실행한 플랫폼에 맞춰서 컴파일 하는 구조를 가지고 있다.


◈ CIL (공통 중간 언어)
ㄴ 닷넷 프레임워크에서 실행되는 언어
ㄴ 닷넷 프레임워크 언어로 개발된 프로그램 코드는 컴파일시 바이너리 형태로 CIL이라고 불리는 파일로 작성이 된다.
ㄴ 다른 코드들을 .Net Framework의 규칙들로 일원화 시킨다.


◈ .Net Framework
ㄴ Windows 프로그램 개발 및 실행 환경
ㄴ 네트워크 작업을 하거나 인터페이스 등의 작업을 할때 캡슐화하여 코딩의 효율을 올려주는 역할을 한다.
ㄴ 특징으로는 CLS를 따르는 언어라면 어떠한 언어라도 닷넷 프레임워크에서 실행이 가능하다.
ㄴ 또한 CLR이라는 가상 기계 위에서 작동을 하기 때문에 플랫폼에 독립적이고 궁극적으로는 코딩을 하는데 더 편한 환경을 제공한다. (함수 + API 지원)


◈ CLS
ㄴ 닷넷에서 지키는 규칙을 따르는 것

- 결국 C# 언어는 컴파일이 되었을 경우 운영체제에서 바로 실행할 수 있는 네이티브 코드로 변환되는 것이 아니라
CLR에서 인식할 수 있는 CIL이라는 중간 언어를 생성하는 것이다.

- 그리고 CLR 구동중에 CIL 코드를 읽어 들여서 특정 운영체제에 맞는 네이티브 코드로 변환이 된다.
    ㄴ 이러한 방식을 JIT 컴파일 방식이라고 한다.

★ C# 프로그램은 궁극적으로 컴파일 + 인터프리터 방식의 혼합 하이브리드 방식으로 구동이 된다.


◈ JIT (Just-In Time)

장점
ㄴ 프로그램이 구동중에 즉시 네이티브 코드를 생성하기 때문에 특정 운영체제에 맞는 최적화 코드를 만들어내는 것이 가능하다.


단점
ㄴ 시간이 걸린다. (오버헤드 발생 시 아주 느려짐)


◈ CTS (Common Type System)
ㄴ 공용 타입 시스템
ㄴ 닷넷 호환 언어가 지켜야 할 타입의 표준 규격으로 닷넷 호환 언어를 만든다면 CTS 규칙을 반드시 지켜야 한다.
ㄴ CTS 규격을 전부 따를 필요없지만 CTS 규격을 벗어나는 새로운 타입은 지원하지 않는다.


◈ 가비지 컬렉션 (GC) (고려대상 1순위)
ㄴ 1. 스택 메모리 관리
    ㄴ 스택 메모리는 지역적인 특징을 지니고 있기 때문에 시스템에 의해서 관리된다.
    ㄴ 메모리 관리를 위한 추가적인 로직이 불필요하다.
ㄴ 2. 힙에 대한 메모리 관리
    ㄴ C / C++ 언어와는 달리 힙 메모리는 프로그래머에 의해서 직접적으로 관리되지 않는다.
    ㄴ 이를 GC에서 관리한다는 특징이 있다.

- C#언어 같은 경우에는 힙 메모리를 프로그래머가 직접적으로 관리하는 C / C++ 언어와는 달리
C# 언어의 힙 메모리는 가비지 컬렉션에 의해서 관리가 된다.
ㄴ 이는 메모리 릭에 대한 걱정을 하지 않아도 된다는 얘기

- GC는 0 / 1 / 2 세대 존재 => 전체 가비지 컬렉션

- GC는 기본적으로 단방향이다. (아래로)

- 할 수 있다면 참조 관계 형성을 안하는게 제일 베스트 (EX : 클래스 대신 구조체)


º 장점

- 메모리 릭에 대한 걱정을 하지 않아도 된다.


º 단점

- C# 언어는 힙 메모리를 할당하는것은 가능하지만 직접적으로 관리되지 않기 때문에 불필요한
메모리 공간을 즉시 제거하는 것이 불가능하다.

- 이는 곧 불필요한 메모리가 존재한다는 것을 알고 있다 하더라도 제거할 수 있는 권한자체가 없기 때문에
GC가 구동될때까지 데이터는 메모리에 상주한다.

- 또한 GC에 의한 메모리 관리는 많은 부하를 일으키는 원인이 된다.
ㄴ 이는 곧 항상 GC의 상태에 신경을 써서 프로그램 로직을 작성해야 한다는 얘기
ㄴ 추가로 많은 퍼포먼스가 필요한 게임에서는 최적화에 대한 많은 노력이 필요하다.

- 메모리의 파편화(단편화)가 발생한다.


▶ C# 언어 자료형 특징

- C# 언어는 기본적으로 모든 데이터가 클래스 또는 객체로 인식된다.
ㄴ 이말인즉슨 int, float, double 등의 기본 자료형도 내부적으로 클래스로 표현된다는 것을 의미한다.

- 또한 C# 언어의 자료형의 데이터 타입에 따라서 값 타입과 참조 타입으로 나뉜다.

- 그리고 데이터의 형식에 따라서 기본 데이터 형식과 복합 데이터 형식으로 구분이 된다.

※ 복합 데이터 : 클래스 안에 구조체 + 배열


▷ C# 언어 변수 특징

- C# 언어의 모든 클래스는 오브젝트 클래스를 직 / 간접적으로 상속하는 것이 원칙이다.
ㄴ 즉, 오브젝트 타입의 변수로 모든 데이터를 보관하는 것이 가능하다.

- 이렇게 변수를 오브젝트 타입으로 다른 데이터 형식의 값을 제어하느 것을 박싱 / 언박싱이라고 한다.

★★★★★ 면접 문제 ★★★★★
- 박싱은 데이터를 보관하는 행위 (고려대상 2순위)
ㄴ 오브젝트 타입은 기본적으로 참조 형식 => 해당 변수에 값 형식의 변수가 복사될 경우 내부적으로 힙 메모리를 이용해서 값을 복사한다.
ㄴ 퍼포먼스 저하를 일으키는 요인이 있다.

- 언박싱은 데이터를 읽어들이는 행위 (고려대상 2순위)
ㄴ 퍼포먼스 저하를 일으키는 요인이 있다.
ㄴ 값을 보관하고 있는 힙 메모리의 값을 읽어 들인다.

- 데이터 타입이 확정되기 전까지는 오브젝트 타입이라고 부른다.

- 오브젝트 타입의 변수는 기본적으로 참조 타입이기때문에 해당 변수에 참조 타입의 값을 보관할때는
퍼포먼스 저하를 일으키지 않지만 값 형식의 데이터를 보관할때는 박싱 / 언박싱을 수행하기 때문에 퍼포먼스 저하가 발생한다.


º C# 값 형식 데이터 타입

※ u가 붙으면 부호가 없다는 의미

- byte (0 ~ 255), sByte(-128 ~ 127)

- int, uint, long, ulong, short, ushort

- float (7), double (15), decimal (29; 사용을 권장하지 않는다., 느리고 메모리 사용량이 많다 16 byte)

- char

- enum

- struct

- Nullable


º C# 참조 형식 데이터 타입 (NULL 대입이 가능하면 참조 형식이다.)

- object : 박싱과 언박싱 과정 중 값 형식으로 바뀔 수 있다.
- string
- class
- delegate


- 값 / 참조 형식의 차이점은 스택으로 할당이 이뤄지냐 / 힙으로 이뤄지냐의 차이

- 값 타입은 스택에 할당되기 때문에 시스템에 의해서 메모리가 관리되고 값을 할당할때 내부적으로 복사가 수행된다. (값 자체의 복사)

- 참조 타입의 자료형은 힙에 할당되기 때문에 GC에 의해서 메모리가 관리되며 값을 할당할때 참조 값의 복사가 이뤄진다. (해당 메모리의 주소가 할당된다.)


º Nullable

- 참조 타입의 변수는 null 키워드를 통해서 데이터의 유효성 검사가 가능

- 반면 값 타입의 변수는 null 키워드 사용 자체가 불가
ㄴ 이는 값 자체로 올바른 값인지의 유무를 판단하는것이 불가능하다는 얘기

- 그렇기 때문에 Nullable 타입이라는 자료형을 지원하여 값 타입의 유효성 검사를 수행할 수 있다.

 
*/
#endregion

public class Example_04 : MonoBehaviour
{
    void Awake()
    {
#if EXAMPLE_TYPE_VALUE
        int nValue = 10;
        float fValue = 3.14f;
        double dValue = 3.14;
        decimal mValue = 3.14m;

        Debug.LogFormat("데이터 출력 : {0}, {1}, {2}, {3}", nValue, fValue, dValue, mValue);

#elif EXAMPLE_TYPE_REFERENCE
        object oValue = 10;
        string oString = "HellFire";

        // $ : C# 6.0에서 추가된 기능
        // ㄴ 문자열 보간 (보간된 문자열로 식별)
        // 2의 배수로 보간을 하여 문자를 캐시 데이터로 저장한다.
        Debug.Log($"데이터 출력 : {oValue}, {oString}");

#else
        int? nValue = null;
        float? fValue = null;
        System.Nullable<int> nValueB = 10;

        if (nValue.HasValue)
        {
            Debug.Log("정수형 값이 유효");
        }

        else
        {
            Debug.Log("정수형 값이 유효하지 않음");
        }

        if (fValue != null)
        {
            Debug.Log("실수형 값이 유효");
        }

        else
        {
            Debug.Log("실수형 값이 유효하지 않음");
        }

        if (nValueB.HasValue)
        {
            Debug.Log("정수형 값이 유효");
        }

        else
        {
            Debug.Log("정수형 값이 유효하지 않음");
        }

#endif
    }

    void Start()
    {
        
    }

    void Update()
    {
        
    }
}